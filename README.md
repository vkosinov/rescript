Получить опыт разработки на полностью функциональном языке. Изучить ReasonML/Rescript/Melange ([обзор разницы между ними](https://discuss.ocaml.org/t/what-is-actually-going-on-now-with-reasonml-and-rescript/13973/)) и написать приложение на нём и React 

**Теория:** Изучить особенности OCaml: pattern matching. локальное связывание, использование optional type, рекурсия, монады, [gadt](https://dev.realworldocaml.org/gadts.html). 
Обратить внимание на [first-class modules](https://markkarpov.com/post/what-does-a-humped-critter-have-to-teach-us.html), сравнить их с подходом тайпклассов, совмещение функционального и объектного подхода, модульное устройство компилятора и сборщика (благодаря чему возможны проекты типа Reason.ml), Type-driven development ([1](https://blog.ploeh.dk/2015/08/10/type-driven-development/), [2](https://www.packtpub.com/en-us/product/learn-type-driven-development-9781788838016)). В качестве справочника можно использовать [1](https://dev.realworldocaml.org/toc.html) и [2](http://reasonmlhub.com/exploring-reasonml/toc.html) (в случае
 выбора ReasonML).

**Практика:** Реализовать React-приложение на ReScript или ReasonML,
 использовать уникальные фичи OCaml в процессе разработки.
 Можно совместить с опциональной целью 4 и использовать [это решение](https://reason-react-native.github.io/) для
 разработки под React Native. Можно взять готовые приложения ([1](https://github.com/async-labs/builderbook/tree/master), [2](https://github.com/gothinkster/realworld)) и
 переписать их на ReasonML. Хороший вариант — попробовать реализовать
 базовое приложение на React Native + ReasonML/ReScript + Expo, и затем
 добавлять функционал самого приложения.
